# 题目

## ACID是靠什么保证的

+ A(原子性) 靠的是undolog来保证,记录了要回滚的信息,事务发生回滚的时候撤销已经执行成功的sql
+ C(一致性)靠的是其他三大特征来保证业务上的一致
+ I(隔离性)靠的是MVCC机制
+ D(持久性)靠的是redolog来保证,修改数据时会保存日志到redolog中,就算数据没有保存成,只要日志成功,数据也不会丢失

## BeanFactory和ApplicationContext有什么区别

1. 相同点

+ spring提供了两种不同的IOC容器,BeanFactory和ApplicationContext,都是interface接口,其中ApplicationContext继承于BeanFactory

+ 它们都可以用来配置XML属性,支持属性自动注入

+ 都提供了getBean("bean name")来获取bean

2. 不同点

+ getBean实例化Bean时机不同,BeanFactory仅实例化bean,ApplicationContext在容器启动的时候实例化单例Bean,不会在调用getBean的时候实例化
+ BeanFactory不支持国际化,ApplicationContext支持国际化
+ ApplicationContext支持事件发布到注册为监听器的bean,BeanFactory不支持
+ 实现不同,BeanFactory核心实现是XMLBeanFactory,ApplicationContext核心实现是ClassPathXmlApplicationContext,web容器则是WebApplicationContext

3. 总结

BeanFactory提供基本的IOC和DI功能,ApplicationContext提供高级功能

## HashMap有哪些线程安全的方式

+ Collections.synchronizedMap
+ ConcueerntHashMap

## HashMap在扩容的时候做了什么优化

JDK1.8 二倍扩容,减少位置计算

## MVCC解决的问题是什么
```
数据库并发场景:
1. 读读: 不存在任何问题,不需要并发控制
2. 读写: 有线程安全问题,可能会造成事务隔离性问题,遇到脏读,幻读,不可重复读
3. 写写: 有线程安全问题,可能 存在更新丢失问题
```
MVCC是一种用来解决读写冲突的无锁并发控制.也就是为事务分配增长的时间戳,为每个修改保存一个版本,版本与时间戳关联,读操作只读事务开始前的数据库快照,所以可以解决以下问题:

1. 并发读写数据库时,可以左端读操作不阻塞写操作,写操作也不阻塞读操作,提供数据库并发读写性能
2. 解决脏读,幻读,不可重复读等事务隔离问题,但是不能解决更新丢失问题 


## MVCC实现原理

mvcc实现原理主要依赖于记录中的隐藏字段,undolog,read view来实现


## MySQL复制原理


![mysql复制原理图](img/mysql复制图.jpg)]

+ 从库会生成2个线程,一个I/O线程,一个SQL线程
+ I/O线程会请求主库的binlog,得到binlog后会写到本地的relay-log(中继日志)文件中
+ 主库会生成一个log dump线程,给从库I/O线程传binlog
+ SQL线程会读取relay log文件,解析成sql语句进行逐一执行


## mysql 索引原理和结构

1. 索引结构

msql主要用到两种结构: B+ Tree索引和Hash索引

innodb存储引擎默认是B+Tree索引

Memory存储引擎默认Hash索引

+ Hash索引: 查询单条快,范围查询慢
+ Btree索引: B+树,层级越多,数据量指数级增长


## mysql锁类型

按锁的属性分为: 共享锁,排他锁

按锁的粒度分为: 行级锁,表级锁,页级锁

按锁的状态分为: 意向共享锁,意向排他锁

+ 共享锁: 共享锁又称读锁,简称S锁;当一个事务为数据加上读锁后,其他事务只能加读锁不能加写锁,直到所有读锁释放后才能加写锁.读锁主要支持鬓发读取数据,但不支持修改数据,避免出现重复读问题
+ 排它锁: 排它锁称写锁;当一个事务为数据加上写锁后,其他请求不能加任何锁,直到锁释放后才能对数据镜像加锁.目的为了防止数据修改时,不允许其他同事修改
+ 表锁: 整个表加锁
+ 行锁: 单挑记录加锁


## springMVC 工作流程

![mysql复制原理图](img/springmvc.jpg)]